<?php

/**
 * Each instance of this class defines a controller and the URL pattern that triggers its execution.
 */
class Controller {

	/********************************************************************************************************/
	/*******************************************  CONSTANTS  ************************************************/
	/********************************************************************************************************/
	
	/**
	 * @var string Regex used for parameters in URI pattern when none is provided explicitely.
	 */
	const REGEX_PARAMETER = '[^/]+';
	
	/********************************************************************************************************/
	/*********************************************  STATIC  *************************************************/
	/********************************************************************************************************/
	
	/**
	 * @var array Array of defined controllers.
	 */
	static protected $controllers = array();
	
	/**
	 * Registers a new controller.
	 * 
	 * @param string $path
	 */
	static public function execute($path) {
		static::$controllers[$path] = new static($path);
		return static::$controllers[$path];
	}
	
	/**
	 * Returns the controller of given path.
	 * 
	 * @param string $path
	 */
	static public function get($path) {
		return static::$controllers[$path];		
	}
	
	/**
	 * Returns the controller collection matching the given expression.
	 *
	 * @param string $expr
	 * @return ControllerCollection
	 */
	static public function find($expr) {
		// If expr is an expression, turn it into a closure :
		if ( ! is_callable($expr)) {
			$expr = function(Controller $controller) use ($expr) {
				return $controller->match($expr);
			};
		}
		
		// Loop on controllers and find those that match $expr :
		$collection = array();
		foreach(static::$controllers as $controller) {
			if ($expr($controller))
				$collection[] = $controller;
		}		
		
		// Return collection :
		return new ControllerCollection($collection);	
	}
	
	/**
	 * Finds the controller that matches the requested URI and returns its response. 
	 */
	static public function dispatch() {
		$uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		foreach(static::$controllers as $controller) {
			if (in_array($_SERVER['REQUEST_METHOD'], $controller->methods)) {
				$uri_params = $controller->extract_parameters($uri);
				if ($uri_params !== false) {
					$params = $controller->resolve_bindings($uri_params);
					return call_user_func_array(array($controller, 'content'), $params);	
				}
			}
		}
		throw new Exception("No registered controller matches the following uri : " . $uri);
	}
	
	/**
	 * Turns the pattern into a regex ready to be matched against an URI.
	 *
	 * @return string
	 */
	static protected function create_regex($pattern) {
		$regex = '`^'; 
		$result = preg_split('`(\\<[^:>]+(?:\\:[^>]+)?\\>)`', $pattern, -1, PREG_SPLIT_DELIM_CAPTURE);
		foreach($result as $segment) {
			if (preg_match('`^\\<([^:>]+)(?:\\:([^>]+))?\\>$`', $segment, $matches)) {
				if ( ! isset($matches[2])) $matches[2] = static::REGEX_PARAMETER;
				$regex .= '(?<' . $matches[1] . '>' . $matches[2] . ')';
			}
			else 
				$regex .= preg_quote($segment);
		}
		return $regex . '$`i';
	}
	
	/********************************************************************************************************/
	/********************************************  INSTANCE  ************************************************/
	/********************************************************************************************************/
	
	/**
	 * @var string Path to this controller closure.
	 */
	protected $path;
	
	/**
	 * @var array Acceptable HTTP methods.
	 */	
	protected $methods;
	
	/**
	 * @var string URI patterns.
	 */	
	protected $patterns;
	
	/**
	 * @var array Bindings that describe from where to pull the value of each function argument.
	 */
	protected $bindings;
	
	/**
	 * @var string URI patterns turned into regexes.
	 */	
	protected $regexes;
	
	/**
	 * @var Closure Closure that generates and returns the content of this controller.
	 */
	protected $implementation;
	
	/**
	 * @var array Wrappers that surround the content generated by this controller.
	 */
	protected $wrappers = array();
	
	/**
	 * Constructor.
	 * 
	 * @param string $path
	 */
	protected function __construct($path) {
		$this->path = $path;
	}
	
	/**
	 * Specifies the HTTP methods accepted by this controller.
	 */
	public function on() {
		$this->methods = func_get_args();
		return $this;
	}
	
	/**
	 * Specifies the URI patterns that trigger the execution of this controller.
	 */
	public function matching() {
		$patterns = func_get_args();
		foreach($patterns as $pattern)
			$this->patterns[] = URI_ROOT . $pattern;
		return $this;
	}
	
	/**
	 * Implementation getter.
	 * 
	 * @return Closure
	 */
	protected function implementation() {
		if ( ! isset($this->implementation))
			$this->load_implementation();
		return $this->implementation;
	}
	
   /**
    * Bindings getter.
    * 
    * @return array
    */
   protected function bindings() {
        if ( ! isset($this->bindings))
            $this->load_implementation();
        return $this->bindings;
    }
    
    /**
     * Lazy loads implementation and bindings.
     */
    protected function load_implementation() {
    	$x = require(DIR_ROOT_CONTROLLERS . '/' . $this->path . '.php');
    	if (is_array($x))
    		list($this->bindings, $this->implementation) = $x;
    	else {
    		// Implementation :
    		$this->implementation = $x;
    		
    		// Bindings :
	        $this->bindings = array();
	        $function = new ReflectionFunction($this->implementation);
	        foreach($function->getParameters() as $parameter)
               $this->bindings[] = Bind::ANY($parameter->getName());
    	}
    }
	
	/**
	 * Returns the patterns turned into a regexes ready to be matched against an URI. 
	 * 
	 * @return array
	 */
	protected function regexes() {
		if ( ! isset($this->regexes)) {
			foreach($this->patterns as $pattern)
				$this->regexes[] = static::create_regex($pattern);
		}
		return $this->regexes;
	}
	
	/**
	 * Matches the given URI against the regexes of the current resource. Returns the array of parameters
	 * if the URI matches, or false otherwise.
	 * 
	 * @param string $uri
	 * @return mixed
	 */
	protected function extract_parameters($uri) {
		foreach($this->regexes() as $regex) {
			if (preg_match($regex, $uri, $matches)) {
				array_shift($matches);
				return $matches;
			}
		}
		return false;
	}
	
	/**
	 * Extract the parameter list from the superglobal arrays according to bindings.
	 * 
	 * @param array $uri_params
	 * @return array
	 */
	protected function resolve_bindings($uri_params) {
		$params = array();
		$any = $uri_params + $_GET + $_POST;
		foreach($this->bindings() as $binding)
			$params[] = $binding->fetch($uri_params, $_GET, $_POST, $any);
		return $params;
	}
	
	/**
	 * Returns the content of this resource for the given parameters, with all wrappers applied.
	 * 
	 * @return string
	 */
	public function content() {
		return $this->wrapping(func_get_args())->content();
	}
	
	/**
	 * Wraps a controller call for the given parameters into the defined stack of wrappers.
	 * 
	 * @param array $params
	 * @return Resource_Wrapped
	 */
	protected function wrapping($params) {
		$resource = new Resource_Request($this, $params);
		foreach($this->wrappers as $wrapper)
			$resource = new Resource_Wrapped($wrapper, $resource);
		return $resource;
	}
	
	/**
	 * Returns the content of this resource for the given parameters, without any wrappers applied.
	 * 
	 * @return string
	 */
	public function raw() {
		return call_user_func_array($this->implementation(), func_get_args());
	}
	
	/**
	 * Returns the URI of the current controller for the given parameters.
	 * 
	 * @param array $params
	 */
	public function uri() {
		// Generate parameters arrays :
		$params = func_get_args();
		$uri = $get = $post = $any = array();
		foreach($this->bindings() as $index => $binding)
			list($uri, $get, $post, $any) = $binding->store($params[$index], $uri, $get, $post, $any);
		if ( ! empty($post)) throw new Exception("Cannot generate URI.");
		
		// Split $any array into $uri and $get according to available URI parameters :
	    foreach($any as $name => $value) {
	    	if (preg_match("`\\<$name(\\:[^>]+)?\\>`", $this->patterns[0]))
                $uri[$name] = $value;
            else
                $get[$name] = $value;
        }
		
		// Build URI part :
		$patterns = $replacements = array();
		foreach($uri as $name => $value) {
			$patterns[] = "`\\<$name(\\:[^>]+)?\\>`";
			$replacements[] = $value;
		}
		$uri_string = preg_replace($patterns, $replacements, $this->patterns[0], 1);
		
		// Build query string :
		$query_string = http_build_query($get);
		
		// Return URI :
		return $uri_string . (empty($query_string) ? '' : ('?' . $query_string));
	}
	
	/**
	 * Adds a wrapper on the wrapper stack.
	 * 
	 * @param Wrapper $wrapper
	 * @return Controller
	 */
	public function wrap(Wrapper $wrapper) {
		$this->wrappers[] = $wrapper;
		return $this;
	}
	
	/**
	 * Returns true if the path of this controller matches the given expression.
	 * 
	 * @param string $expr
	 */
	public function match($expr) {
		$expr = preg_quote($expr);
		$expr = '`^' . strtr($expr, array('\\*\\*' => '.*', '\\*' => '[^/]*')) . '$`i';
		return preg_match($expr, $this->path) === 1;
	}
}