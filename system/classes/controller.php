<?php

/**
 * Each instance of this class defines a controller and the URL pattern that triggers its execution.
 */
class Controller {

	/********************************************************************************************************/
	/*******************************************  CONSTANTS  ************************************************/
	/********************************************************************************************************/
	
	/**
	 * @var string Regex used for parameters in URI pattern when none is provided explicitely.
	 */
	const REGEX_PARAMETER = '[^/]+';
	
	/********************************************************************************************************/
	/*********************************************  STATIC  *************************************************/
	/********************************************************************************************************/
	
	/**
	 * @var array Array of defined controllers.
	 */
	static protected $controllers = array();
	
	/**
	 * Register a new controller.
	 * 
	 * @param string $identifier
	 */
	static public function register($identifier) {
		static::$controllers[$identifier] = new static($identifier);
		return static::$controllers[$identifier];
	}
	
	/**
	 * Returns the controller of given identifier.
	 * 
	 * @param string $identifier
	 */
	static public function get($identifier) {
		return static::$controllers[$identifier];		
	}
	
	/**
	 * Returns the controller collection matching the given expression.
	 *
	 * @param string $expr
	 * @return ControllerCollection
	 */
	static public function find($expr) {
		// If expr is an expression, turn it into a closure :
		if ( ! is_callable($expr)) {
			$expr = function(Controller $controller) use ($expr) {
				return $controller->match($expr);
			};
		}
		
		// Loop on controllers and find those that match $expr :
		$collection = array();
		foreach(static::$controllers as $controller) {
			if ($expr($controller))
				$collection[] = $controller;
		}		
		
		// Return collection :
		return new ControllerCollection($collection);	
	}
	
	/**
	 * Finds the controller that matches the requested URI and returns its response. 
	 */
	static public function dispatch() {
		$uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		foreach(static::$controllers as $identifier => $controller) {
			if (in_array($_SERVER['REQUEST_METHOD'], $controller->methods)) {
				$uri_params = $controller->extract_parameters($uri);
				if ($uri_params !== false) {
					$params = $controller->resolve_bindings($uri_params, $_GET, $_POST, $_COOKIE, $_REQUEST);
					return call_user_func_array(array($controller, 'content'), $params);	
				}
			}
		}
		throw new Exception("No registered controller matches the following uri : " . $uri);
	}
	
	/********************************************************************************************************/
	/********************************************  INSTANCE  ************************************************/
	/********************************************************************************************************/
	
	/**
	 * @var string Identifier of this controller.
	 */
	protected $identifier;
	
	/**
	 * @var array Acceptable HTTP methods.
	 */	
	protected $methods;
	
	/**
	 * @var string URI pattern.
	 */	
	protected $pattern;
	
	/**
	 * @var array Bindings that describe from where to pull the value of each function argument.
	 */
	protected $bindings;
	
	/**
	 * @var string URI pattern turned into a regex.
	 */	
	protected $regex;
	
	/**
	 * @var callable Callable that generates and returns the content of this controller.
	 */
	protected $implementation;
	
	/**
	 * @var array Wrappers that surround the content generated by this controller.
	 */
	protected $wrappers = array();
	
	/**
	 * Constructor.
	 * 
	 * @param string $identifier
	 */
	protected function __construct($identifier) {
		$this->identifier		= $identifier;
	}
	
	/**
	 * Implementation getter.
	 * 
	 * @return callable
	 */
	protected function implementation() {
		if ( ! isset($this->implementation))
			$this->load_implementation();
		return $this->implementation;
	}
	
   /**
    * Bindings getter.
    * 
    * @return array
    */
   protected function bindings() {
        if ( ! isset($this->bindings))
            $this->load_implementation();
        return $this->bindings;
    }
    
    /**
     * Lazy loads implementation and bindings.
     */
    protected function load_implementation() {
    	list($this->bindings, $this->implementation) = require(DIR_ROOT_CONTROLLERS . '/' . $this->identifier . '.php'); 
    }
	
	/**
	 * Returns the pattern turned into a regex ready to be matched against an URI. 
	 * 
	 * @return string
	 */
	protected function regex() {
		if ( ! isset($this->regex))
			$this->regex = $this->create_regex();
		return $this->regex;
	}
	
	/**
	 * Turns the pattern into a regex ready to be matched against an URI. 
	 * 
	 * @return string
	 */
	protected function create_regex() {
		$regex = '`^'; 
		$result = preg_split('`(\\<[^:>]+(?:\\:[^>]+)?\\>)`', $this->pattern, -1, PREG_SPLIT_DELIM_CAPTURE);
		foreach($result as $segment) {
			if (preg_match('`^\\<([^:>]+)(?:\\:([^>]+))?\\>$`', $segment, $matches)) {
				if ( ! isset($matches[2])) $matches[2] = static::REGEX_PARAMETER;
				$regex .= '(?<' . $matches[1] . '>' . $matches[2] . ')';
			}
			else 
				$regex .= preg_quote($segment);
		}
		return $regex . '$`i';
	}
	
	/**
	 * Matches the given URI against the regex of the current resource. Returns the array of parameters
	 * the URI matches, or false otherwise.
	 * 
	 * @param string $uri
	 * @return mixed
	 */
	protected function extract_parameters($uri) {
		return preg_match($this->regex(), $uri, $matches) ? $matches :  false;
	}
	
	/**
	 * Extract the parameter list from the given arrays according to bindings.
	 * 
	 * @param array $uri
	 * @param array $get
	 * @param array $post
	 * @param array $cookies
	 * @param array $request
	 * @return array
	 */
	protected function resolve_bindings(array $uri, array $get, array $post, array $cookie, array $request) {
		$params = array();
		foreach($this->bindings() as $binding)
			$params[] = $binding->fetch($uri, $get, $post, $cookie, $request);
		return $params;
	}
	
	/**
	 * Returns the content of this resource for the given parameters, with all wrappers applied.
	 * 
	 * @return string
	 */
	public function content() {
		return $this->wrapping(func_get_args())->content();
	}
	
	/**
	 * Wraps a controller call for the given parameters into the defined stack of wrappers.
	 * 
	 * @param array $params
	 * @return Resource_Wrapped
	 */
	protected function wrapping($params) {
		$resource = new Resource_Request($this, $params);
		foreach($this->wrappers as $wrapper)
			$resource = new Resource_Wrapped($wrapper, $resource);
		return $resource;
	}
	
	/**
	 * Returns the content of this resource for the given parameters, without any wrappers applied.
	 * 
	 * @return string
	 */
	public function raw() {
		return call_user_func_array($this->implementation(), func_get_args());
	}
	
	/**
	 * Returns the URI of the current controller for the given parameters.
	 * 
	 * @param array $params
	 */
	public function uri() {
		// Generate URI and GET parameters arrays :
		$params = func_get_args();
		$uri = $get = $post = $cookie = $request = array();
		foreach($this->bindings() as $index => $binding)
			list($uri, $get, $post, $cookie, $request) = $binding->store($params[$index], $uri, $get, $post, $cookie, $request);
		if ( ! empty($post) || ! empty($cookie)) throw new Exception("Cannot generate URI.");
		$get = array_merge($get, $request);
		
		// Build URI part :
		$patterns = $replacements = array();
		foreach($uri as $name => $value) {
			$patterns[] = "`\\<$name(\\:[^>]+)?\\>`";
			$replacements[] = $value;
		}
		$uri_string = preg_replace($patterns, $replacements, $this->pattern, 1);
		
		// Build query string :
		$query_string = http_build_query($get);
		
		// Return URI :
		return $uri_string . (empty($query_string) ? '' : ('?' . $query_string));
	}
	
	/**
	 * Adds a wrapper on the wrapper stack.
	 * 
	 * @param Wrapper $wrapper
	 * @return Controller
	 */
	public function wrap(Wrapper $wrapper) {
		$this->wrappers[] = $wrapper;
		return $this;
	}
	
	/**
	 * Returns true if the identifier of this controller matches the given expression.
	 * 
	 * @param string $expr
	 */
	public function match($expr) {
		$expr = preg_quote($expr);
		$expr = '`^' . strtr($expr, array('\\*\\*' => '.*', '\\*' => '[^/]*')) . '$`i';
		return preg_match($expr, $this->identifier) === 1;
	}
	
	/**
	 * Specifies the HTTP methods accepted by a controller and which URI pattern triggers its execution.
	 * 
	 * @param mixed $methods
	 * @param string $pattern
	 */
	public function on($methods, $pattern) {
		$this->methods = is_array($methods) ? $methods : array($methods);
		$this->pattern = URI_ROOT . $pattern;
		return $this;
	}
	
	/**
	 * Specifies what to execute and how to extract arguments from superglobal arrays.
	 *
	 * @param array $bindings
	 * @param callable $implementation
	 */
	public function execute(array $bindings, $implementation = null) {
		$this->bindings			= $bindings;
		$this->implementation	= $implementation;
		return $this;
	}
}